



\lstset{language=R}
\begin{lstlisting}
library(raster)
library(rasterVis)

fn <- system.file("external/test.grd", package="raster")
r <- raster(fn)
r <- r-700

rg <- c(minValue(r), maxValue(r))
mx <- max(abs(rg))
rgExt <- c(-mx, mx)
\end{lstlisting}


\lstset{language=R}
\begin{lstlisting}
####################
## Con approxfun
ramp <- colorRamp(c('red', 'white', 'blue'))##brewer.pal(9, 'RdBu'))
breaksExt <- seq(-mx, mx, length.out=200)
normScale <- seq(0, 1, length.out=length(breaksExt))
foo <- approxfun(breaksExt, normScale)
## Evidentemente foo(0)=0.5 --> corresponde al color que esté en el medio justo de la escala

breaks <- seq(rg[1], rg[2], length.out=9)
##seq(minValue(r), maxValue(r), length.out=nBreaks)
## pero debiera dar un color menos que nBreaks
pal <- rgb(ramp(foo(breaks)), maxColorValue=255)
## Compruebo que rgb(ramp(foo(0)), maxColorValue=255) dat #F7F7F7 ('white' en brewer.pal)
levelplot(r, par.settings=rasterTheme(region=pal))
\end{lstlisting}

\includegraphics[width=.9\linewidth]{figs/colors_approxFun.pdf}



\lstset{language=R}
\begin{lstlisting}
## Con findInterval
ramp <- colorRampPalette(brewer.pal(9, 'PuOr'))(100)
breaksExt <- seq(-mx, mx, length.out=100+1)
idx <- findInterval(seq(rg[1], rg[2], length=10), breaksExt, rightmost.closed=TRUE)
pal <- ramp[idx]
levelplot(r, par.settings=rasterTheme(region=pal))##,
\end{lstlisting}

\includegraphics[width=.9\linewidth]{figs/colors_findInterval.pdf}


\lstset{language=R}
\begin{lstlisting}
## Con ecuación de la recta
## y-y0=m(x-x0)
## y0=0; x0=-mx
## m=1/(2*mx)


rg <- c(minValue(r), maxValue(r))
rg <- lattice:::extend.limits(rg)
mx <- max(abs(rg))
rgExt <- c(-mx, mx)

ramp <- colorRamp(c('red', 'white', 'blue'))##brewer.pal(9, 'RdBu'))
foo <- function(x)1/2*(x/rgExt[2] + 1)
## evidentemente foo(0)=0.5


breaks <- seq(rg[1], rg[2], length.out=10)

dRg <- diff(rg)
breaksNeg <- seq(0, rg[1], by=-dRg/10)
breaksPos <- seq(0, rg[2], by=dRg/10)
breaks <- c(rev(breaksNeg), breaksPos[-1])
pal <- rgb(ramp(foo(breaks)), maxColorValue=255)
levelplot(r, par.settings=rasterTheme(region=pal))
\end{lstlisting}

\includegraphics[width=.9\linewidth]{figs/colors_lineEquation.pdf}




\lstset{language=R}
\begin{lstlisting}
## classInt
library(raster)
library(rasterVis)
library(classInt)

fn <- system.file("external/test.grd", package="raster")
r <- raster(fn)
r <- r-600

## r <- raster(nrow=100, ncol=100)
## r[] <- colFromCell(r, seq_len(ncell(r))) - 50.5

cl <- classIntervals(r[],
                     ## n=15, style='equal')
                     ## style='hclust')
                     ## style='sd')
                     style='kmeans')
                     ## style='quantile')
cl

## Puntos "medios" de los intervalos. Serán realmente los puntos
## centrales de cada intervalo si style='equal', ¿para el
## resto?. 
## mids <- (cl$brks[-length(cl$brks)] + cl$brks[-1])/2
## mids

## Mejor calculamos la mediana para cada intervalo
idx <- findInterval(r[], cl$brks, rightmost.closed=TRUE)
mids <- tapply(r[], idx, median)
mids
## máximo de los dos extremos
##mx <- max(abs(cl$brks))
mx <- max(abs(mids))

## Función para crear una secuencia de colores interpolando a
## partir de otra origen. Devuelve tres valores (RGB) para cada
## número en el intervalo [0, 1]. El 0 corresponde a el extremo
## inferior de la escala original y el 1 al extremo superior. Para
## 0.5 debe entregar los valores RGB que corresponden al color
## central de la escala (aprox. blanco en una red-white-blue),
## #F7F7F7 en la RdBu de ColorBrewer.
ramp <- colorRamp(##c('indianred1', 'white', 'midnightblue'))
                  brewer.pal(9, 'RdBu'))

## ramp(0.5) ## 247, 247, 247 para una RdBu de ColorBrewer
## rgb(ramp(0.5), maxColorValue=255) ## #F7F7F7 para un white de ColorBrewer

## Ecuación de la recta que relaciona el intervalo [0, 1] con el
## intervalo [-mx, mx] (simétrico en 0). Una forma más sofisticada
## es usar approxfun para interpolar.

foo <- function(x)1/2*(x/mx + 1)
## foo(mx) ##1
## foo(-mx) ##0
## foo(0) ##0.5

## Paleta de colores correspondientes a los límites de los
## intervalos calculados con classIntervals. Esta paleta tiene un
## color de más (se necesita un color menos que número de
## cortes). Al estar construida a partir de ramp y foo, el 0
## estará situado aproximadamente en el límite entre el rojo y el
## azul.
## pal <- rgb(ramp(foo(cl$brks)), maxColorValue=255)

pal <- rgb(ramp(foo(mids)), maxColorValue=255)

## barplot(rep(1, length(pal)), col=pal,
##         names.arg=round(mids, 1), cex.names=0.6)

## Igual, pero ahora no tomamos en cuenta el limite inferior del
## rango. De esta forma, el número de colores coincide con el
## número de intervalos.
## pal2 <- rgb(ramp(foo(cl$brks[-1])), maxColorValue=255)
## pie(1:length(pal2), col=pal2)


## La asignación de colores a intervalos se realiza internamente
## mediante la función level.colors. Si hay más colores de los
## necesarios, se queda con los colores extremos y descarta alguno
## de los intermedios (mediante un round).
levelplot(r, par.settings=rasterTheme(region=pal),
          at=cl$brks)
\end{lstlisting}

\includegraphics[width=.9\linewidth]{figs/colors_classInt.pdf}





\lstset{language=R}
\begin{lstlisting}
myTheme <- rasterTheme()

myTheme$regions$col <- pal
levelplot(r, par.settings=myTheme, at=cl$brks)
\end{lstlisting}

\includegraphics[width=.9\linewidth]{figs/colors_classInt_brks.pdf}

