#+PROPERTY:  session *R*
#+PROPERTY:  tangle yes

#+begin_src R :exports none
  setwd('~/Dropbox/chapman/book/')
  load('data/unemployUSA.RData')
#+end_src

* Unemployment


This =zoo= object can be directly displayed with the =xyplot.zoo= method. 

#+begin_src R :results output graphics :exports both :file "~/Dropbox/chapman/book/figs/unemployUSAxyplot.pdf" 
  xyplot(unemployUSA, superpose=TRUE,
         par.settings=custom.theme.2,
         auto.key=list(space='right'))
#+end_src


This graphical output is not very useful: the legend is confusing with
too many items; the vertical scale is dominated by two series with the
bulk of the series buried in the lower part of the scale; the trend,
variations and structure of the total and the individual contributions
cannot be deduced from this graph.

A suitable improvement is to display the multivariate time series as a
set of stacked colored polygons with a time line at the bottom: the
ThemeRiver.

##** Theme River

## introducir el Theme River!!
\cite{Havre.Hetzler.ea2002} The ThemeRiver visualization displays
time series with stacked colored polygons in the context of a time
line at the bottom of the figure. This combination allows a user
to discern patterns in individual themes and among multiple themes
relative to time. These patterns may reveal trends, relationships,
anomalies, and structure in the data.
## REESCRIBIR: copiado del art√≠culo


##** Defining a panel function

The =xyplot= function displays information according to the class
of its first argument (methods) and to the =panel= function. We
will use the =xyplot.zoo= method (equivalent to the =xyplot.ts=
method) with a new custom =panel= function.
This new function has four main arguments, three of them calculated by
=xyplot= (=x=, =y= and =groups=) and a new one, =origin=. Of
course, it includes the =...= argument to provide additional
arguments.

\index{Panel function}
\index{superpose.polygon@\texttt{superpose.polygon}}
\index{trellis.par.get@\texttt{trellis.par.get}}
\index{apply@\texttt{apply}}
\index{sapply@\texttt{sapply}}
\index{unstack@\texttt{unstack}}
\index{panel.text@\texttt{panel.text}}
\index{panel.polygon@\texttt{panel.polygon}}
#+begin_src R 
  panel.flow <- function(x, y, groups, origin, ..., pos=4){
    dat <- data.frame(x=x, y=y, groups=groups)
    nVars <- nlevels(groups)
    groupLevels <- levels(groups)
  
    yWide <- unstack(dat, y~groups)
  
    ##Havre.Hetzler.ea2002
    if (origin=='themeRiver') origin= -1/2*rowSums(yWide)
    else origin=0 
  
    yWide <- cbind(origin=origin, yWide)
    yCumSum <- t(apply(yWide, 1, cumsum))
    Y <- as.data.frame(sapply(seq_len(nVars),
                              function(iCol)c(yCumSum[,iCol+1],
                                              rev(yCumSum[,iCol]))))
    names(Y) <- levels(groups)
    y <- stack(Y)$values
  
    xWide <- unstack(dat, x~groups)
    x <- rep(c(xWide[,1], rev(xWide[,1])), nVars)
  
    groups <- rep(groups, each=2)
    
    superpose.polygon <- trellis.par.get("superpose.polygon")
  
    col = superpose.polygon$col
    border = superpose.polygon$border 
    lwd = superpose.polygon$lwd 
  
    for (i in seq_len(nVars)){
      xi <- x[groups==groupLevels[i]]
      yi <- y[groups==groupLevels[i]]
      panel.polygon(xi, yi, border=border,
                    lwd=lwd, col=col[i])
      N <- length(xi)/2
      panel.text(xi[N], (yi[N]+yi[N+1])/2,
                 labels=groupLevels[i],
                 col=col[i], pos=pos, ...)
    }
  }
#+end_src

The first step is to create a =data.frame= with the coordinates
and with the =groups= factor. The value and number of its levels
will be used in the main step of this =panel= function.With this
=data.frame= we have to calculate the =y= and =x= coordinates for
each group to get an stacked set of polygons.

This =data.frame= is in the /long/ format, with a row for each
observation where the =group= column identifies the
variable. Thus, it has to transformed to the /wide/ format, with a
column for each variable. With the =unstack= function a new
=data.frame= is produced, whose columns are defined according to
the formula =y ~ groups= and with a row for each time
position. The stack of polygons is the result of the cumulative
sum of each row (=apply(yWide, 1, cumsum)=). The origin of this sum
is defined with the corresponding =origin= argument: with =origin
= 'themeRiver'= the polygons are arranged in a symmetric way.

Each column of this matrix of cumulative sums defines the =y=
coordinate of each variable (where =origin= is now the first
variable). The polygon of each variable is comprised between this
curve (=iCol+1=) and the one of the previous variable (=iCol=). In
order to get a closed polygon, the coordinates of the inferior
limit are in reverse order. This new =data.frame= (=Y=) is in the
/wide/ format, but =xyplot= requires the information in the /long/
format: the =y= coordinates of the polygons are extracted from the
=values= column of the /long/ version of this =data.frame=.

The =x= coordinates are produced in easier way. Again, =unstack=
produces a =data.frame= with column for each variable and a row
for each time position but now, since the =x= coordinates are the same
for the set of polygons, the corresponding vector is constructed
directly with a combination of concatenation a repetition.

Finally, the =groups= vector is produced repeating each element of
the column of the original =data.frame= (=dat$groups=) twice to
account for the forward and reverse curves of the corresponding
polygon.

The last step before displaying the polygons is to acquire the
graphical settings. The information retrieved with
=trellis.par.get= is transferred to the corresponding arguments of
=panel.polygon=.

Everything is ready for constructing the polygons. With a =for=
loop the coordinates of the corresponding group are extracted from
the =x= and =y= vectors. A polygon is displayed with
=panel.polygon= and labelled with =panel.text= (where the labels
are the =levels= of the original =groups= variable,
=groupLevels=). Both the polygon and its label share the same
color (=col[i]=).

With this panel function, =xyplot= will display a set of stacked
polygons corresponding to the multivariate time series. However,
the graphical window is not large enough and part of the polygons
fall out of it. Why?


#+begin_src R :results output graphics :exports both :file "~/Dropbox/chapman/book/figs/ThemeRiverError.pdf" 
  library(colorspace)
  
  nCols <- ncol(unemployUSA)
  pal <- rainbow_hcl(nCols, c=70, l=75, start=30, end=300)
  myTheme <- custom.theme(fill=pal, lwd=0.4)
  
  xyplot(unemployUSA, superpose=TRUE, auto.key=FALSE,
         panel=panel.flow, origin='themeRiver',
         par.settings=myTheme, cex=0.4, offset=0,
         scales=list(y=list(draw=FALSE)))
#+end_src

The problem is that =lattice= makes a preliminary estimate of the
window size using a default =prepanel= function which is unaware
of the internal calculations of our new =panel.flow= function. The
solution is to define a new =prepanel.flow= function. The input
arguments and first lines are exactly the same as in
=panel.flow=. The output is a list whose elements are the limits
for each axis (=xlim= and =ylim=), and the sequence of differences
(=dx= and =dy=) which can be used for the aspect and banking
calculations. The limits of the x-axis are defined with the range
of the time index, while the limits of the y-axis are calculated
with the minimum of the first column of =yyy= (the origin line)
and with the maximum of its last column (the upper line of the
cumulative sum).

#+begin_src R 
  prepanel.flow <- function(x, y, groups, origin,...){
    dat <- data.frame(x=x, y=y, groups=groups)
    nVars <- nlevels(groups)
    groupLevels <- levels(groups)
    yWide <- unstack(dat, y~groups)
    if (origin=='themeRiver') origin= -1/2*rowSums(yWide)
    else origin=0
    yWide <- cbind(origin=origin, yWide)
    yCumSum <- t(apply(yWide, 1, cumsum))
  
    list(xlim=range(x),
         ylim=c(min(yCumSum[,1]), max(yCumSum[,nVars+1])),
         dx=diff(x),
         dy=diff(c(yCumSum[,-1])))
  }
#+end_src

The output of =xyplot= using both the panel and prepanel functions
is displayed in the figure fig:unemployUSAThemeRiver.

#+CAPTION: Theme River of unemployment at USA
#+LABEL: fig:unemployUSAThemeRiver
#+begin_src R :results output graphics :exports both :file "/home/oscar/Dropbox/chapman/book/figs/unemployUSAThemeRiver.pdf" 
  xyplot(unemployUSA, superpose=TRUE, auto.key=FALSE,
         panel=panel.flow, prepanel=prepanel.flow,
         origin='themeRiver', scales=list(y=list(draw=FALSE)),
         par.settings=myTheme, cex=0.4, offset=0)
#+end_src
