#+PROPERTY:  session *R*
#+PROPERTY:  tangle yes

#+begin_src R :exports none
  ##################################################################
  ## Source code for the book: "Displaying time series, spatial and
  ## space-time data with R: stories of space and time"
  
  ## Copyright (C) 2012 Oscar Perpiñán Lamigueiro
  
  ## This program is free software you can redistribute it and/or modify
  ## it under the terms of the GNU General Public License as published
  ## by the Free Software Foundation; either version 2 of the License,
  ## or (at your option) any later version.
   
  ## This program is distributed in the hope that it will be useful, but
  ## WITHOUT ANY WARRANTY; without even the implied warranty of
  ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  ## General Public License for more details.
   
  ## You should have received a copy of the GNU General Public License
  ## along with this program; if not, write to the Free Software
  ## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  ## 02111-1307, USA.
  ####################################################################
  
  setwd('~/Dropbox/chapman/book/')
#+end_src

In my previous posts I wrote about maps with complex legends but
without any kind of interactivity.  In this post I show how to produce
an [[http://en.wikipedia.org/wiki/Scalable_Vector_Graphics][SVG]] file with interactive functionalities with the [[http://cran.r-project.org/web/packages/gridSVG/][gridSVG]] package.

As an example, I use a dataset about population from the Spanish
[[http://ine.es/][Instituto Nacional de Estadística]]. This organism publishes information
using the [[http://www.scb.se/Pages/StandardNoLeftMeny____314045.aspx][PC_Axis]] format which can be imported into R with the [[http://cran.r-project.org/web/packages/pxR/][pxR]]
package. This dataset is available at the [[http://www.ine.es/jaxi/menu.do?type%3Dpcaxis&path%3D%252Ft20%252Fe260%252Fa2009%252F&file%3Dpcaxis&N%3D&L%3D0][INE webpage]] or directly
[[http://dl.dropbox.com/u/40293713/annotateMap/pcaxis-676270323.px][here]]. 

Let's start loading packages.
#+begin_src R
library(gridSVG)
library(pxR)
library(sp)
library(lattice)
library(latticeExtra)
library(maptools)
library(classInt)
library(colorspace)
#+end_src

Then I read the =px= file and make some changes to get the =datWide=
=data.frame= (which is available [[http://dl.dropbox.com/u/40293713/annotateMap/datWide.Rda][here]] if you don't want to use =pxR=).
#+begin_src R
datPX <- read.px('pcaxis-676270323.px', encoding='latin1') 

datWide <- as.data.frame(datPX, direction = 'wide', use.codes=FALSE)

provID <- strsplit(as.character(datWide$provincias), '  ')
provID <- as.data.frame(do.call(rbind, provID))
names(provID) <- c('code', 'prov')

datWide <- cbind(datWide, provID)
#+end_src

Now it's time to read a suitable =shapefile= (read [[http://procomun.wordpress.com/2012/02/18/maps_with_r_1/][the first post of
this series]] for information about it).

#+begin_src R
mapSHP <-  readShapePoly(fn = 'mapas_completo_municipal/spain_provinces_ind_2')
Encoding(levels(mapSHP$NOMBRE99)) <- "latin1"
## The encoding must be UTF8 to be correctly displayed in the SVG file
levels(mapSHP$NOMBRE99) <- enc2utf8(levels(mapSHP$NOMBRE99))
#+end_src

Both the =shapefile= and the =data.frame= have to be combined using
the matches between the =PROV= variable of the =shapefile= and =code= from the =data.frame=.
The numeric values of the row names (=mapaIDs=) will be useful in the last step.

#+begin_src R
idx <- match(mapSHP$PROV, datWide$code)
Total <- datWide[idx, "Total"]
mapSHP@data <- cbind(mapSHP@data, Total)
mapaDat <- as.data.frame(mapSHP)
mapaIDs <- as.numeric(rownames(mapaDat))
#+end_src

A final step is needed before calling =spplot=. I will use the
functions of =gridSVG= to include information in the SVG file
according to the characteristics of each polygon. Since =gridSVG=
works after the plot has been created, I need a key to identify each
polygon and match with the correspondent element of the original
dataset. Unfortunately, the =panel.polygonsplot= (which is the
function used by =spplot= when drawing polygons) [[http://www.stat.auckland.ac.nz/~paul/R/Names/MurrellNames.pdf][does not assign a
name]] to each polygon. Let's create a new function
(=panel.polygonNames=) adding a small change in =panel.polygonsplot=
(you should read the full code of =panel.polygonsplot= to understand
what is happening here).
#+begin_src R
panel.str <- deparse(panel.polygonsplot, width=500)

panel.str <- sub("grid.polygon\\((.*)\\)",
                 "grid.polygon(\\1, name=paste('ID', slot(pls\\[\\[i\\]\\], 'ID'\\), sep=':'))",
                 panel.str)

panel.polygonNames <- eval(parse(text=panel.str),
                           envir=environment(panel.polygonsplot))
#+end_src

Now everything is ready for drawing. I use the [[http://books.google.es/books?id%3D4gg8yx_lcj0C&lpg%3DPA78&ots%3DyzcH8v813H&dq%3Dclass%2520Intervals%2520fisher&pg%3DPA77#v%3Donepage&q%3Dclass%2520Intervals%2520fisher&f%3Dfalse][jenks]] style of the
=classIntervals= function from the [[http://cran.r-project.org/web/packages/classInt/index.html][classInt]] package to set the breaks
of the color key.

#+begin_src R
n=7
int <- classIntervals(Total, n, style='jenks')
pal <- brewer.pal(n, 'Blues')

p <- spplot(mapSHP["Total"], panel=panel.polygonNames,
            col.regions=pal, at=signif(int$brks, digits=2))
p
#+end_src

Once the plot has been created (do not close the graphic window!) the
=grid.garnish= attaches SVG attributes (in this example =onmouseover=
and =onmouseout=) to each polygon, which is identified with its name
thanks to the =panel.polygonNames=.

These attributes are related to =javascript= functions (=showTooltip=
and =hideTooltip=) included in this [[http://dl.dropbox.com/u/40293713/annotateMap/tooltip.js][javascript file]] (this file is only
a minor modification of the original file available at the [[http://www.stat.auckland.ac.nz/~paul/gridSVG/][webpage of
the creator of =grid= and =gridSVG=]]). The =grid.script= function
attaches the =javascript= file to the =grob= and =gridToSVG= produces
the SVG file with a simple HTML page.

#+begin_src R
## grobs in the graphical output
grobs <- grid.ls()
## only interested in those with "ID:" in the name
nms <- grobs$name[grobs$type == "grobListing"]
idxNames <- grep('ID:', nms)
IDs <- nms[idxNames]

for (id in unique(IDs)){
  ## extract information from the data 
  ## according to the ID value
  i <- strsplit(id, 'ID:')
  i <- sapply(i, function(x)as.numeric(x[2]))
  dat <- mapaDat[which(mapaIDs==i),]
  ## Information to be attached to each polygon
  info <- paste(dat$NOMBRE99, dat$Total, sep=':')
  g <- grid.get(id)
  ## attach SVG attributes
  grid.garnish(id, 
               onmouseover=paste("showTooltip(evt, '", info, "')"),
               onmouseout="hideTooltip()")
}

grid.script(filename="tooltip.js")

gridToSVG('map_with_annotations.svg')
#+end_src

(Click on the image to show the SVG graphic. Move the mouse over it to display the information)

[[http://dl.dropbox.com/u/40293713/annotateMap/map_with_annotations.svg.html][file:map.jpg]]


