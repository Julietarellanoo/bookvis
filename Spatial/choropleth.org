#+PROPERTY:  header-args :session *R* :tangle ../docs/R/choropleth.R :eval no-export
#+OPTIONS: ^:nil
#+BIND: org-latex-image-default-height  "0.45\\textheight"

#+begin_src R :exports none :tangle no
setwd('~/github/bookvis/')
#+end_src


#+begin_src R :exports none  
##################################################################
## Initial configuration
##################################################################
## Clone or download the repository and set the working directory
## with setwd to the folder where the repository is located.
  
library(lattice)
library(ggplot2)
library(latticeExtra)
  
myTheme <- custom.theme.2(pch = 19, cex = 0.7,
                          region = rev(brewer.pal(9, 'YlOrRd')),
                          symbol = brewer.pal(n = 8, name = "Dark2"))
myTheme$strip.background$col='transparent'
myTheme$strip.shingle$col='transparent'
myTheme$strip.border$col='transparent'

xscale.components.custom <- function(...)
{
    ans <- xscale.components.default(...)
    ans$top = FALSE
    ans
}

yscale.components.custom <- function(...)
{
    ans <- yscale.components.default(...)
    ans$right = FALSE
    ans
}

myArgs <- list(as.table = TRUE,
               between = list(x = 0.5, y = 0.2),
               xscale.components = xscale.components.custom,
               yscale.components = yscale.components.custom)

defaultArgs <- lattice.options()$default.args


lattice.options(default.theme = myTheme,
                default.args = modifyList(defaultArgs, myArgs))
  
#+end_src


* Choropleth Maps
\label{sec:multiChoropleth}
#+begin_src R :exports none
##################################################################
## Choropleth maps
##################################################################
#+end_src

A choropleth map shades regions according to the measurement of a
variable displayed on the map. The choropleth map is an appropriate
tool to visualize a variable uniformly distributed within each region,
changing only at the region boundaries. This method performs correctly
with homogeneous regions, both in size and shape.

This section details how to create choropleth maps depicting the
results of the 2016 Spanish general elections. The section
ref:sec:dataChoropleth describes how to define a
=SpatialPolygonsDataFrame= combining the data from a =data.frame= and
the spatial information of the administrative boundaries from a
shapefile. The result is stored in the =data= folder, in a set of
files named =spMapVotes.*=. You can visit it for details if you are
interested in this procedure.

#+begin_src R 
library(sp)
library(maptools)

spMapVotes <- readShapePoly(fn = "data/spMapVotes", 
                        proj4string = CRS("+proj=utm +zone=30 +ellps=GRS80 +units=m +no_defs"))
#+end_src

This =SpatialPolygonsDataFrame= contains two main variables:
=whichMax=, the name of the predominant political option, and =pcMax=,
the percentage of votes obtained by this political option.

#+begin_src R :results output :exports results :tangle no
summary(spMapVotes)
#+end_src

#+RESULTS:
#+begin_example
Object of class SpatialPolygonsDataFrame
Coordinates:
      min     max
x  -13952 1127057
y 3903525 4859444
Is projected: TRUE 
proj4string :
[+proj=utm +zone=30 +ellps=GRS80 +units=m +no_defs]
Data attributes:
    PROVMUN     whichMax         Max               pcMax      
 01001  :   1   ABS :2812   Min.   :     2.0   Min.   :21.33  
 01002  :   1   C.s :   3   1st Qu.:    54.0   1st Qu.:31.68  
 01003  :   1   OTH : 170   Median :   162.0   Median :35.64  
 01004  :   1   PP  :4212   Mean   :  1395.9   Mean   :37.58  
 01006  :   1   PSOE: 776   3rd Qu.:   636.5   3rd Qu.:41.27  
 01008  :   1   UP  : 137   Max.   :696804.0   Max.   :94.74  
 (Other):8104
#+end_example

As a visual aid, the subsequent maps will be produced with the
province boundaries superposed. These boundaries are encoded in the
=spain_provinces= shapefile. The =spplot= function that will generate
the maps, offers the argument =sp.layout= to add additional layers to
the map[fn:2]. This argument should be a list: its first element is the
function to display the layer, the second element is the object to be
represented, and the rest of elements are arguments to the function
defined in the first element.

#+INDEX: sp.layout\texttt{sp.layout}

#+begin_src R
provinces <- readShapePoly(fn="data/spain_provinces",
                        proj4string = CRS("+proj=utm +zone=30 +ellps=GRS80 +units=m +no_defs"))

provinceLines <- list("sp.polygons", provinces, lwd = 0.1)
#+end_src

** Quantitative variable
label:sec:quantitative_choropleth

First, let's display =pcMax=, a quantitative variable increasing from
low to high. This type of variables are well suited to sequential
palettes, that communicate the progression from low to high with light
colors associated to low values, and dark colors linked to high
values. The well-known service ColorBrewer[fn:1] provides several
choices, available in =R= via the =RColorBrewer= package
cite:Neuwirth2011.

#+INDEX: Packages!RColorBrewer\texttt{RColorBrewer}
#+INDEX: brewer.pal\texttt{brewer.pal}

#+begin_src R
library(RColorBrewer)

## Number of intervals (colors)
N <- 6
## Sequential palette
quantPal <- brewer.pal(n = N, "Oranges")
#+end_src

The most common approach with choropleth maps, the classed choropleth,
is to divide the data into classes. Although this method produces a
filtered view of the data, it reduces the random noise in the
information, and makes it easy to compare regions. A different
alternative is the unclassed choropleth, where each unique data value
gets a unique color. This approach is recommended to get a unfiltered
view of the data and highlight overall geographic patterns of the
variable.

Figure ref:fig:pcMaxUC is an unclassed choropleth depicting the
=pcMax= variable. It uses a palette created by interpolation with the
=colorRampPalette= function.
 
#+INDEX: colorRampPalette\texttt{colorRampPalette}

#+begin_src R
ucN <- 1000
ucQuantPal <- colorRampPalette(quantPal)(ucN)
#+end_src

#+begin_src R :results output graphics :exports both :file figs/pcMaxUC.pdf
## The polygons boundaries are not displayed thanks to col = 'transparent' 
spplot(spMapVotes["pcMax"],
       col.regions = ucQuantPal,
       cuts = ucN,
       col = 'transparent',
       sp.layout = provinceLines)    
#+end_src

#+CAPTION: Quantitative choropleth map displaying the percentage of votes obtained by the predominant political option in each municipality in the 2016 Spanish general elections using a continuous color ramp (unclassed choropleth).
#+LABEL: fig:pcMaxUC
#+RESULTS:
[[file:figs/pcMaxUC.pdf]]


It is evident in figure ref:fig:pcMaxUC that the =pcMax= variable is
concentrated in the 0.2-0.4 range. Figure ref:fig:densityChoropleth
displays the density estimation of this variable grouping by the
political option. This result suggests to use data classification.

#+INDEX: ggplot@\texttt{ggplot}
#+INDEX: geom_density\texttt{geom_density}

#+begin_src R :results output graphics :exports both :file figs/densityChoropleth.pdf
ggplot(as.data.frame(spMapVotes),
       aes(pcMax,
           fill = whichMax,
           colour = whichMax)) +
    geom_density(alpha = 0.1) +
    theme_bw()
#+end_src

#+CAPTION: Density estimation of the predominant political option in each municipality in the 2016 Spanish general elections grouping by the political option.
#+LABEL: fig:densityChoropleth
#+RESULTS:
[[file:figs/densityChoropleth.pdf]]

The number of data classes is the result of a compromise between
information amount and map legibility. A general recommendation is to
use 3 to 7 number of classes, depending on the data. 

On the other hand, there is a wide catalog of classification methods,
and the =classInt= package implements most of them (previously used in
section ref:sec:classification_bubble). Figures
ref:fig:quantile_breaks and ref:fig:fisher_quantile depict the
empirical cumulative distribution function of =pcMax= with the
intervals computed with the quantile method and the natural breaks
method, a clustering method that seeks to reduce the variance within
classes and maximize the variance between classes. As it can be
inferred from the density estimation (Figure
ref:fig:densityChoropleth), the natural breaks method is preferred in
this example, because with the quantile method very different values
will be assigned to the same class.

#+INDEX: Packages!classInt@\texttt{classInt}
#+INDEX: classIntervals@\texttt{classIntervals}

#+begin_src R
library(classInt)

## Compute intervals with the same number of elements
intQuant <- classIntervals(spMapVotes$pcMax,
                           n = N, style = "quantile")
## Compute intervals with the natural breaks algorithm
intFisher <- classIntervals(spMapVotes$pcMax,
                            n = N, style = "fisher")
#+end_src

#+RESULTS:

#+begin_src R :results output graphics :exports both :file figs/quantile_intervals.pdf
plot(intQuant, pal = quantPal, main = "")
#+end_src

#+begin_src R :results output graphics :exports both :file figs/fisher_intervals.pdf
plot(intFisher, pal = quantPal, main = "")
#+end_src

#+CAPTION: Quantile method for setting class intervals 
#+LABEL: fig:quantile_intervals
#+RESULTS:
[[file:figs/quantile_intervals.pdf]]
#+CAPTION: Natural breaks method for setting class intervals 
#+LABEL: fig:fisher_intervals
#+RESULTS:
[[file:figs/fisher_intervals.pdf]]


Figure ref:fig:pcMax is a classed choropleth with the natural breaks
classification. It is produced with =spplot= displaying a categorical
variable created with the function =cut= and the breaks computed with
=classIntervals=.

#+begin_src R :results output graphics :exports both :file figs/pcMax.pdf
## Add a new categorical variable with cut, using the computed breaks
spMapVotes$pcMaxInt <- cut(spMapVotes$pcMax,
                            breaks = intFisher$brks)

spplot(spMapVotes["pcMaxInt"],
       col = 'transparent',
       col.regions = quantPal,
       sp.layout = provinceLines)
#+end_src

#+RESULTS:
[[file:figs/pcMax.pdf]]

#+CAPTION: Quantitative choropleth map displaying the percentage of votes obtained by the predominant political option in each municipality in the 2016 Spanish general elections using a classification (classed choropleth).
#+LABEL: fig:pcMax

#+RESULTS:
[[file:figs/pcMax.pdf]]

** Qualitative variable

On the other hand, =whichMax= is a categorical value with four levels:
the main parties (=PP=, =PSOE=, =UP=, =Cs=), the abstention results
(=ABS=), and the rest of the parties (=OTH=). 

#+begin_src R :results output :exports results :tangle no
table(spMapVotes$whichMax)
#+end_src

#+RESULTS:
| ABS  | 2812 |
| C.s  |    3 |
| OTH  |  170 |
| PP   | 4212 |
| PSOE |  776 |
| UP   |  137 |

Figure [[fig:whichMax]] encodes these levels with a qualitative palette from ColorBrewer.

#+INDEX: Packages!RColorBrewer\texttt{RColorBrewer}
#+INDEX: brewer.pal\texttt{brewer.pal}

#+begin_src R 
classes <- levels(factor(spMapVotes$whichMax))
nClasses <- length(classes)

qualPal <- brewer.pal(nClasses, "Dark2")
#+end_src


#+begin_src R :results output graphics :exports both :file figs/whichMax.pdf
spplot(spMapVotes["whichMax"],
       col.regions = qualPal,
       col = 'transparent',
       sp.layout = provinceLines)
#+end_src

#+CAPTION: Categorical choropleth map displaying the name of the predominant political option in each municipality in the 2016 Spanish general elections.
#+LABEL: fig:whichMax
#+RESULTS:
[[file:figs/whichMax.pdf]]

** Categorical and Quantitative Variables combined in a matrix of maps


#+INDEX: spplot@\texttt{spplot}
#+INDEX: lapply@\texttt{lapply}
#+INDEX: do.call\texttt{do.call}

#+begin_src R 
pList <- lapply(1:nClasses, function(i){
    ## Only those polygons corresponding to a level are selected
    mapClass <- subset(spMapVotes, 
                       whichMax == classes[i])
    ## Use natural breaks classification
    mapClass$pcMaxInt <- cut(mapClass$pcMax,
                             breaks = intFisher$brks)
    ## Produce the graphic
    pClass <- spplot(mapClass, "pcMaxInt",
                     col.regions = quantPal,
                     col='transparent',
		     sp.layout = provinceLines)
})
names(pList) <- classes
#+end_src

#+begin_src R
do.call(c, pList)
#+end_src

** Interactive

#+begin_src R
library(mapview)
#+end_src

#+begin_src R
spMapVotes0 <- readShapePoly(fn = "data/spMapVotes0", 
                        proj4string = CRS("+proj=utm +zone=30 +ellps=GRS80 +units=m +no_defs"))

#+end_src

#+begin_src R
mapView(spMapVotes0, zcol = "whichMax",
        legend = TRUE,
        col.regions = qualPal)
#+end_src

#+RESULTS:

#+begin_src R
mapView(spMapVotes0, zcol = "pcMax",
        legend = TRUE,
        col.regions = quantPal)
#+end_src

#+RESULTS:


** COMMENT \floweroneleft Categorical and Quantitative Variables Combined in a Multivariate Choropleth Map
#+begin_src R :exports none
##################################################################
## Categorical and quantitative variables combined in a multivariate choropleth map
##################################################################
#+end_src

Following the inspiring example of the infographic from the /New
York Times/, we will combine both choropleth maps to produce a
multivariate map: the hue of each polygon will be determined by
the name of the predominant option (=whichMax=) but the chroma and
luminance will vary according to the percentage of votes
(=pcMax=). Hues are computed with the same method as in Figure
[[fig:whichMax]], while the corresponding values of chroma and
luminance are calculated with the =sequential_hcl= function.


#+INDEX: sequential_hcl@\texttt{sequential\_hcl}

#+begin_src R
library(colorspace)

classes <- levels(factor(spMapVotes$whichMax))
nClasses <- length(classes)
step <- 360/nClasses
multiPal <- lapply(1:nClasses, function(i){
    rev(sequential_hcl(16, h = (30 + step*(i-1))%%360))
})
#+end_src

With this multivariate palette we can produce a list of maps
extracting the polygons according to each class and filling with
the appropiate color from this palette. The resulting list of
=trellis= objects can be combined with =Reduce= and the
=+.trellis= function of the =latticeExtra= and produce a =trellis=
object.

It is important to note that, to ensure the legend's homogeneity, the
breakpoints defined by the =at= argument are the same for all the
individual maps.


#+INDEX: Reduce@\texttt{Reduce} 
#+INDEX: spplot@\texttt{spplot}

#+begin_src R 
pList <- lapply(1:nClasses, function(i){
    ## Only those polygons corresponding to a level are selected
    mapClass <- spMapVotes[spMapVotes$whichMax==classes[i],]
    pClass <- spplot(mapClass['pcMax'], ##col.regions=multiPal[[i]],
                     col='transparent',
                     ## labels only needed in the last legend
##                     colorkey=(if (i==nClasses) TRUE else list(labels=rep('', 6))),
                     at = seq(0, 100, by=20))
})
names(pList) <- classes

p <- Reduce('+', pList)
#+end_src

The legend of this =trellis= object must be defined manually. The main
operation is to merge the legends from the components of the list of
maps to obtain a bivariate legend.

The first step is to add a title to each individual legend.  This is a
little complex because =levelplot= (the engine under the =spplot=
method) does not include a title in its color key. The solution is to
define a function to add the title and include it as an argument to
the legend component of each =trellis= object. The =print.trellis=
method will process this function when displaying the =trellis=
object. The =frameGrob= and =packGrob= of the =grid= package will do
the main work inside this function.


#+INDEX: textGrob@\texttt{textGrob}
#+INDEX: packGrob@\texttt{packGrob}
#+INDEX: Packages!grid@\texttt{grid}

#+begin_src R
library(grid)

## Function to add a title to a legend
addTitle <- function(legend, title){
    titleGrob <- textGrob(title, gp=gpar(fontsize=8), hjust=1, vjust=1)
    ## retrieve the legend from the trellis object
    legendGrob <- eval(as.call(c(as.symbol(legend$fun), legend$args)))
    ## Layout of the legend WITH the title
    ly <- grid.layout(ncol=1, nrow=2,
                      widths=unit(0.9, 'grobwidth', data=legendGrob))
    ## Create a frame to host the original legend and the title
    fg <- frameGrob(ly, name=paste('legendTitle', title, sep='_'))
    ## Add the grobs to the frame
    pg <- packGrob(fg, titleGrob, row=2)
    pg <- packGrob(pg, legendGrob, row=1)
}

## Access each trellis object from pList...
for (i in seq_along(classes)){
    ## extract the legend (automatically created by spplot)...
    lg <- pList[[i]]$legend$right
    ## ... and add the addTitle function to the legend component of each trellis object
    pList[[i]]$legend$right <- list(fun='addTitle',
                                    args=list(legend=lg, title=classes[i]))
}
#+end_src

Now that every component of =pList= includes a legend with a title,
the legend of the =p= trellis object can be modified to store the
merged legends from the set of components of =pList=.

#+begin_src R
## List of legends
legendList <- lapply(pList, function(x){
    lg <- x$legend$right
    clKey <- eval(as.call(c(as.symbol(lg$fun), lg$args)))
    clKey
})

## Function to pack the list of legends in a unique legend
## Adapted from latticeExtra::: mergedTrellisLegendGrob
packLegend <- function(legendList){
    N <- length(legendList)
    ly <- grid.layout(nrow = 1,  ncol = N)
    g <- frameGrob(layout = ly, name = "mergedLegend")
    for (i in 1:N) g <- packGrob(g, legendList[[i]], col = i)
    g
}

## The legend of p will include all the legends
p$legend$right <- list(fun = 'packLegend',  args = list(legendList = legendList))

#+end_src

Figure [[fig:mapLegends]] displays the result with the province boundaries
superposed (only for the peninsula due to a problem with the
definition of boundaries the Canarian islands in the file) and a
rectangle to separate the Canarian islands from the remainder of the
map.

#+begin_src R
## Read the provinces shape file
provinces <- readShapePoly(fn="data/spain_provinces",
                        proj4string = CRS("+proj=utm +zone=30 +ellps=GRS80 +units=m +no_defs"))
## Omit the Canarian islands
canarias <- provinces$PROV %in% c(35, 38)
peninsulaLines <- provinces[!canarias,]
#+end_src

#+begin_src R :results output graphics :exports both :file figs/mapLegends.png
## Main plot
p +
    ## Provinces boundaries
    layer(sp.polygons(peninsulaLines, lwd = 0.1)) +
    ## Canarian islands
    layer(grid.rect(x=bbIslands[1,1], y=bbIslands[2,1],
                    width=diff(bbIslands[1,]),
                    height=diff(bbIslands[2,]),
                    default.units='native', just=c('left', 'bottom'),
                    gp=gpar(lwd=0.5, fill='transparent')))
#+end_src

#+CAPTION: Spanish general elections results. The map shows the result of the most voted option in each municipality.
#+LABEL: fig:mapLegends
#+RESULTS:
[[file:figs/mapLegends.png]]

* Footnotes

[fn:2] A similar result is obtained with the function =layer= of the =latticeExtra= package. The section ref:sec:quantitative_raster includes examples of this method.

[fn:1] http://colorbrewer2.org

[fn:3] [[http://www.nytimes.com/interactive/2009/03/10/us/20090310-immigration-explorer.html]]



