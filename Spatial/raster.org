#+PROPERTY:  header-args :session *R* :tangle ../docs/R/raster.R :eval no-export
#+OPTIONS: ^:nil
#+BIND: org-latex-image-default-height "0.45\\textheight"

#+begin_src R :exports none :tangle no
  setwd('~/Dropbox/chapman/book/')
#+end_src


#+begin_src R :exports none  
  ##################################################################
  ## Initial configuration
  ##################################################################
  ## Clone or download the repository and set the working directory
  ## with setwd to the folder where the repository is located.
  
#+end_src

* Raster Maps
\label{cha:raster}

#+begin_src R :exports none
  ##################################################################
  ## Raster maps
  ##################################################################
#+end_src

A raster data structure is a matrix of cells organized into rows and
columns where each cell contains a value representing information,
such as temperature, altitude, population density, land use, etc.
This section describes how to display a raster with two different
examples: CM-SAF solar irradiation rasters will illustrate the use of
quantitative data, and land cover and population data from the
NEO-NASA project will exemplify the display of categorical data and
multivariate rasters. Read Chapter \ref{cha:dataSpatial} for
details about these datasets.

** Quantitative Data
#+begin_src R :exports none
  ##################################################################
  ## Quantitative data
  ##################################################################
#+end_src

As an example of quantitative data, this section displays the
distribution of annual solar irradiation over the Iberian peninsula
using the estimates from CM SAF. The =RasterLayer= object of annual
averages of solar irradiation estimated by CM SAF can be easily
displayed with the =levelplot= method of the =rasterVis=
package. Figure [[fig:levelplotCMSAF]] illustrates this raster with
marginal graphics to show the column (longitude) and row (latitude)
summaries of the =RasterLayer= object. The summary is computed with
the function defined by =FUN.margin= (which uses =mean= as the default
value).

#+BEGIN_LaTeX
\index{Packages!raster@\texttt{raster}}
\index{Packages!rasterVis@\texttt{rasterVis}}
\index{levelplot@\texttt{levelplot}}
\index{rasterTheme@\texttt{rasterTheme}}
#+END_LaTeX

#+begin_src R :results output graphics :exports both :file figs/leveplotSISavOrig.pdf
  library(raster)
  library(rasterVis)
  SISav <- raster('data/SISav')
  levelplot(SISav)
#+end_src

#+CAPTION: Annual average of solar radiation displayed with a sequential palette.
#+LABEL: fig:levelplotCMSAF
#+RESULTS:
[[file:figs/leveplotSISavOrig.pdf]]

Although the solar irradiation distribution reveals the physical
structure of the region, it is recommended to add the geographic
context with a layer of administrative boundaries (Figure
\ref{fig:levelplotCMSAF_boundaries}).

#+BEGIN_LaTeX
\index{Packages!maps@\texttt{maps}}
\index{Packages!mapdata@\texttt{mapdata}}
\index{Packages!maptools@\texttt{maptools}}
\index{map2SpatialLines@\texttt{map2SpatialLines}}
#+END_LaTeX

#+begin_src R 
  library(maps)
  library(mapdata)
  library(maptools)
  
  ext <- as.vector(extent(SISav))
  boundaries <- map('worldHires',
                    xlim=ext[1:2], ylim=ext[3:4],
                    plot=FALSE)
  boundaries <- map2SpatialLines(boundaries,
                                 proj4string=CRS(projection(SISav)))
#+end_src

#+BEGIN_LaTeX
\index{Packages!sp@\texttt{sp}}
\index{Packages!latticeExtra@\texttt{latticeExtra}}
\index{sp.lines@\texttt{sp.lines}}
#+END_LaTeX

#+begin_src R :results output graphics :exports both :file figs/leveplotSISavBoundaries.pdf
  levelplot(SISav) + layer(sp.lines(boundaries, lwd=0.5))
#+end_src

#+CAPTION: Annual average of solar radiation with administrative boundaries.
#+LABEL: fig:levelplotCMSAF_boundaries
#+RESULTS:
[[file:figs/leveplotSISavBoundaries.pdf]]

*** Mapview

#+begin_src R
library(mapview)

mapview(SISav, legend = TRUE)
#+end_src

#+begin_src R
  SIAR <- read.csv("data/SIAR.csv")

  spSIAR <- SpatialPointsDataFrame(SIAR[, c(6, 7)],
                                   SIAR[, -c(6, 7)],
                                   proj4str = CRS(projection(SISav)))
#+end_src

#+begin_src R
mapview(SISav, legend = TRUE) + mapview(spSIAR, zcol = 'Estacion')
#+end_src

*** Hill Shading
#+LABEL: sec:hill-shading
#+begin_src R :exports none
##################################################################
## Hill shading
##################################################################
#+end_src
A frequent method to improve the display of meteorological rasters is
the hill shading or shaded relief technique, a method of representing
relief on a map by depicting the shadows that would be cast by high
ground if light comes from a certain sun position (Figure
\ref{fig:hillShading}).

The procedure is as follows:

- Download a Digital Elevation Model (DEM) from the DIVA-GIS service.
#+BEGIN_LaTeX
\index{Data!DIVA-GIS}
#+END_LaTeX

#+begin_src R :eval no-export
  old <- setwd(tempdir())
  download.file('http://biogeo.ucdavis.edu/data/diva/msk_alt/ESP_msk_alt.zip', 'ESP_msk_alt.zip')
  unzip('ESP_msk_alt.zip', exdir='.')
  
  DEM <- raster('ESP_msk_alt')
#+end_src

#+begin_src R :exports none :tangle no
  DEM <- raster('/home/datos/ESP_msk_alt/ESP_msk_alt')
#+end_src

- Compute the hill shade raster with =terrain= and =hillShade= from =raster=.
#+BEGIN_LaTeX
\index{terrain@\texttt{terrain}}
\index{hillShade@\texttt{hillShade}}
#+END_LaTeX

#+begin_src R
  slope <- terrain(DEM, 'slope')
  aspect <- terrain(DEM, 'aspect')
  hs <- hillShade(slope=slope, aspect=aspect,
                  angle=20, direction=30)
#+end_src
#+begin_src R :eval no-export
  setwd(old)
#+end_src

- Combine the result with the previous map using semitransparency.
#+BEGIN_LaTeX
\index{+.trellis@\texttt{+.trellis}}
\index{layer@\texttt{layer}}
#+END_LaTeX

#+begin_src R :results output graphics :exports both :width 2000 :height 2000 :res 300 :file figs/hillShading.png
  ## hillShade theme: gray colors and semitransparency
  hsTheme <- modifyList(GrTheme(), list(regions=list(alpha=0.6)))
  
  levelplot(SISav, panel=panel.levelplot.raster,
            margin=FALSE, colorkey=FALSE) +
      levelplot(hs, par.settings=hsTheme, maxpixels=1e6) +
      layer(sp.lines(boundaries, lwd=0.5))
#+end_src

#+CAPTION: Hill shading of annual average of solar radiation.
#+LABEL: fig:hillShading
#+RESULTS:
[[file:figs/hillShading.png]]

*** Excursus: 3D Visualization label:sec:3dvisualization
#+begin_src R :exports none
##################################################################
## Excursus: 3D visualization
##################################################################
#+end_src
An alternative method for a DEM is 3D visualization where the user can
rotate or zoom the figure. This solution is available thanks to the
=rgl= package, which provides functions for 3D interactive
graphics. The =plot3D= function in the =rasterVis= package is a
wrapper to this package for =RasterLayer= objects.

#+BEGIN_LaTeX
  \index{Packages!rgl@\texttt{rgl}}
  \index{3D visualization}
  \index{WebGL}
  \index{STL}
#+END_LaTeX

#+begin_src R
plot3D(DEM, maxpixels = 5e4)
#+end_src

The output scene can be exported to several formats such as =STL= with
=writeSTL=, a format commonly used in 3D printing, or WebGL with
=writeWebGL= to be rendered in a browser (Figure \ref{fig:DEM_web}).

#+begin_src R :eval no-export
par3d(viewport = c(0, 30, 250, 250))

writeWebGL(filename = 'docs/images/rgl/DEM.html',
           width = 800)
#+end_src

#+CAPTION: 3D visualization of a Digital Elevation Model using the WebGL format. label:fig:DEM_Web
[[file:figs/DEM_WebGL.png]]

*** Diverging Palettes
#+begin_src R :exports none
  ##################################################################
  ## Diverging palettes
  ##################################################################
#+end_src

Next, instead of displaying the absolute values of each cell, we will
analyze the differences between each cell and the global average
value. This average is computed with the =cellStats= function and
substracted from the original =RasterLayer=. Figure
\ref{fig:xyplotSISav} displays the relation between these scaled
values and latitude (=y=), with five different groups defined by the
longitude (=cut(x, 5)=). It is evident that larger irradiation values
are associated with lower latitudes. However, there is no such clear
relation between irradiation and longitude.

#+BEGIN_LaTeX
\index{cellStats@\texttt{cellStats}}
#+END_LaTeX

#+begin_src R
meanRad <- cellStats(SISav, 'mean')
SISav <- SISav - meanRad
#+end_src

#+BEGIN_LaTeX
\index{xyplot@\texttt{xyplot}}
\index{rasterTheme@\texttt{rasterTheme}}
\index{Packages!hexbin@\texttt{hexbin}}
\index{plinrain@\texttt{plinrain}}
#+END_LaTeX

#+begin_src R :results output graphics :exports both :width 2000 :height 2000 :res 300 :file figs/xyplotSISav.png 
  xyplot(layer ~ y, data = SISav,
         groups=cut(x, 5),
         par.settings=rasterTheme(symbol=plinrain(n=5, end=200)),
         xlab = 'Latitude', ylab = 'Solar radiation (scaled)',  
         auto.key=list(space='right', title='Longitude', cex.title=1.3))
#+end_src

#+CAPTION: Relation between scaled annual average radiation and latitude for several longitude groups.
#+LABEL: fig:xyplotSISav
#+RESULTS:
[[file:figs/xyplotSISav.png]]

Numerical information ranging in an interval including a neutral
value is commonly displayed with diverging palettes. These
palettes represent neutral classes with light colors, while low
and high extremes of the data range are highlighted using dark
colors with contrasting hues. I use the Purple-Orange palette from
ColorBrewer with purple for positive values and orange for
negative values. In order to underline the position of the
interval containing zero, the center color of this palette is
substituted with pure white. The resulting palette is displayed in
Figure \ref{fig:showDivPal} with the custom =showPal=
function. The corresponding correspondent raster map produced with this palette
is displayed in Figure \ref{fig:divPal_SISav_naive}.  Although
extreme positive and negative values can be easily discriminated,
the zero value is not associated with white because the data range
is not symmetrical around zero.

#+BEGIN_LaTeX
\index{Package!RColorBrewer@\texttt{RColorBrewer}}
\index{brewer.pal@\texttt{brewer.pal}}
#+END_LaTeX

#+begin_src R :results output graphics :exports both :file figs/showDivPal.pdf
  divPal <- brewer.pal(n=9, 'PuOr')
  divPal[5] <- "#FFFFFF"
  
  showPal <- function(pal, labs=pal, cex=0.6, ...){
    barplot(rep(1, length(pal)), col=pal,
            names.arg=labs, cex.names=cex,
            axes=FALSE, ...)
  }
  
  showPal(divPal)
#+end_src

#+CAPTION: Purple-Orange diverging palette using white as middle color.
#+LABEL: fig:showDivPal
#+ATTR_LaTeX: :height 0.3\textheight
#+RESULTS:
[[file:figs/showDivPal.pdf]]


#+begin_src R :results output graphics :exports both :file figs/divPal_SISav_naive.pdf
  divTheme <- rasterTheme(region=divPal)
  
  levelplot(SISav, contour=TRUE, par.settings=divTheme)
#+end_src

#+CAPTION: Asymmetric raster data (scaled annual average irradiation) displayed with a symmetric diverging palette.
#+LABEL: fig:divPal_SISav_naive
#+RESULTS:
[[file:figs/divPal_SISav_naive.pdf]]

The solution is to connect the symmetrical color palette with the
asymmetrical data range. The first step is to create a set of
breaks such that the zero value is the center of one of the
intervals.
#+begin_src R 
  rng <- range(SISav[])
  ## Number of desired intervals
  nInt <- 15
  ## Increment corresponding to the range and nInt
  inc0 <- diff(rng)/nInt
  ## Number of intervals from the negative extreme to zero
  n0 <- floor(abs(rng[1])/inc0)
  ## Update the increment adding 1/2 to position zero in the center of an interval
  inc <- abs(rng[1])/(n0 + 1/2)
  ## Number of intervals from zero to the positive extreme
  n1 <- ceiling((rng[2]/inc - 1/2) + 1)
  ## Collection of breaks
  breaks <- seq(rng[1], by=inc, length= n0 + 1 + n1)
#+end_src

The next step is to compute the midpoints of each interval. These
points represent the data belonging to each interval, and their value
will be connected with a color of the palette.
#+BEGIN_LaTeX
\index{findInterval@\texttt{findInterval}}
\index{tapply@\texttt{tapply}}
#+END_LaTeX

#+begin_src R 
  ## Midpoints computed with the median of each interval
  idx <- findInterval(SISav[], breaks, rightmost.closed=TRUE)
  mids <- tapply(SISav[], idx, median)
  ## Maximum of the absolute value both limits
  mx <- max(abs(breaks))
  mids
#+end_src

A simple method to relate the palette and the intervals is with a
straight line such that a point is defined by the absolute maximum
value, (=(mx, 1)=), and another point by zero, (=(0, 0.5)=).  Why are
we using the interval [0, 1] as the =y=-coordinate of this line, and
why is 0.5 the result of zero? The reason is that the input of the
=break2pal= function will be the result of =colorRamp=, a function
that creates another interpolating function which maps colors with
values between 0 and 1. Therefore, a new palette is created,
extracting colors from the original palette, such that the central
color (white) is associated with the interval containing zero. This
palette is displayed in Figure \ref{fig:showBreak2Pal}.

The raster map produced with this new palette is displayed in Figure
\ref{fig:divPalSISav}. Now zero is clearly associated with the white
color.
#+BEGIN_LaTeX
\index{colorRamp@\texttt{colorRamp}}
\index{rgb@\texttt{rgb}}
#+END_LaTeX
#+begin_src R :results output graphics :exports both :file figs/showBreak2Pal.pdf
  break2pal <- function(x, mx, pal){
    ## x = mx gives y = 1
    ## x = 0 gives y = 0.5
    y <- 1/2*(x/mx + 1)
    rgb(pal(y), maxColorValue=255)
  }
  
  ## Interpolating function that maps colors with [0, 1]
  ## rgb(divRamp(0.5), maxColorValue=255) gives "#FFFFFF" (white)
  divRamp <- colorRamp(divPal)
  ## Diverging palette where white is associated with the interval
  ## containing the zero
  pal <- break2pal(mids, mx, divRamp)
  showPal(pal, round(mids, 1))
#+end_src

#+CAPTION: Modified diverging palette related with the asymmetrical raster data.
#+LABEL: fig:showBreak2Pal
#+ATTR_LaTeX: :height 0.3\textheight
#+RESULTS:
[[file:figs/showBreak2Pal.pdf]]


#+begin_src R :results output graphics :exports both :file figs/divPalSISav.pdf
  levelplot(SISav, par.settings=rasterTheme(region=pal),
            at=breaks, contour=TRUE)
#+end_src

#+CAPTION: Asymmetric raster data (scaled annual average irradiation) displayed with a modified diverging palette.
#+LABEL: fig:divPalSISav
#+RESULTS:
[[file:figs/divPalSISav.pdf]]


It is interesting to note two operations carried out internally by
the =lattice= package. First, the =custom.theme= function (used by
=rasterTheme=) creates a new palette with 100 colors using
=colorRampPalette= to interpolate the palette passed as an
argument. Second, the =level.colors= function makes the
arrangement between intervals and colors. If this function
receives more colors than intervals, it chooses a subset of the
palette disregarding some of the intermediate colors. Therefore,
because this function will receive 100 colors from =par.settings=, it
is difficult to control exactly which colors of our original
palette will be represented.

An alternative way for finer control is to fill the =regions$col=
component of the theme with our palette after it has been created
(Figure \ref{fig:divPal_SISav_regions}).

#+begin_src R :results output graphics :exports both :file figs/divPalSISav_regions.pdf
  divTheme <- rasterTheme()
  
  divTheme$regions$col <- pal
  levelplot(SISav, par.settings=divTheme, at=breaks, contour=TRUE)
#+end_src

#+CAPTION: Same as Figure \ref{fig:divPalSISav} but colors are assigned directly to the =regions$col= component of the theme.
#+LABEL: fig:divPal_SISav_regions
#+RESULTS:
[[file:figs/divPalSISav_regions.pdf]]

A final improvement to this map is to compute the intervals using a
classification algorithm with the =classInt= package. With this
approach it is likely that zero will not be perfectly centered in its
corresponding interval. The remaining code is exactly the same as
above, replacing the =breaks= vector with the result of the
=classIntervals= function. Figure \ref{fig:divPalSISav_classInt}
displays the result.

#+BEGIN_LaTeX
\index{Packages!classInt@\texttt{classInt}}
\index{classIntervals@\texttt{classIntervals}}
#+END_LaTeX

#+begin_src R 
  library(classInt)
  
  cl <- classIntervals(SISav[],
                       ## n=15, style='equal')
                       ## style='hclust')
                       ## style='sd')
                       style='kmeans')
                       ## style='quantile')
  cl
  breaks <- cl$brks
#+end_src

#+begin_src R :results output graphics :exports both :file figs/divPalSISav_classInt.pdf
  idx <- findInterval(SISav[], breaks, rightmost.closed=TRUE)
  mids <- tapply(SISav[], idx, median)
  mids
  mx <- max(abs(breaks))
  pal <- break2pal(mids, mx, divRamp)
  divTheme$regions$col <- pal
  levelplot(SISav, par.settings=divTheme, at=breaks, contour=TRUE)
#+end_src

#+CAPTION: Same as Figure \ref{fig:divPal_SISav_regions} but defining intervals with the optimal classification method.
#+LABEL: fig:divPalSISav_classInt
#+RESULTS:
[[file:figs/divPalSISav_classInt.pdf]]


** Categorical Data
#+begin_src R :exports none
  ##################################################################
  ## Categorical data
  ##################################################################
#+end_src

Land cover is the observed physical cover on the Earth's surface. A
set of seventeen different categories is commonly used. Using
satellite observations, it is possible to map where on Earth each of
these seventeen land surface categories can be found and how these
land covers change over time.

This section illustrates how to read and display rasters with
categorical information using information from the NEO-NASA
project. After the land cover and population density files have been
downloaded, two =RasterLayers= can be created with the =raster=
package. Both files are read, their geographical extent reduced to the
area of India and China, and cleaned (=99999= cells are replaced with
=NA=).

#+BEGIN_LaTeX
\index{Packages!raster@\texttt{raster}}
\index{extent@\texttt{extent}}
\index{crop@\texttt{crop}}
#+END_LaTeX

#+begin_src R :eval no-export
  library(raster)
  ## China and India  
  ext <- extent(65, 135, 5, 55)
  
  pop <- raster('875430rgb-167772161.0.FLOAT.TIFF')
  pop <- crop(pop, ext)
  pop[pop==99999] <- NA
  
  landClass <- raster('241243rgb-167772161.0.TIFF')
  landClass <- crop(landClass, ext)
#+end_src

#+begin_src R :exports none :tangle no
  library(raster)
  
  ext <- extent(65, 135, 5, 55)
  
  pop <- raster('~/Datos/Nasa/875430rgb-167772161.0.FLOAT.TIFF')
  pop <- crop(pop, ext)
  pop[pop==99999] <- NA
  
  landClass <- raster('~/Datos/Nasa/241243rgb-167772161.0.TIFF')
  landClass <- crop(landClass, ext)
#+end_src

Each land cover type is designated with a different key: the sea is
labeled with 0; forests with 1 to 5; shrublands, grasslands, and
wetlands with 6 to 11; agriculture and urban lands with 12 to 14; and
snow and barren with 15 and 16.  These four groups (sea is replaced by
=NA=) will be the levels of the categorical raster. The =raster=
package includes the =ratify= method to define a layer as categorical
data, filling it with integer values associated to a Raster Attribute
Table (RAT).

# #+BEGIN_LaTeX
# \begin{figure}
# \includegraphics[width=0.3\textwidth]{figs/lcc_key.jpg}
# \caption{\label{fig:lccKey}Codes of land cover classification}
# \end{figure}
# #+END_LaTeX

#+BEGIN_LaTeX
\index{ratify@\texttt{ratify}}
\index{cut@\texttt{cut}}
#+END_LaTeX

#+begin_src R
  landClass[landClass %in% c(0, 254)] <- NA
  ## Only four groups are needed:
  ## Forests: 1:5
  ## Shrublands, etc: 6:11
  ## Agricultural/Urban: 12:14
  ## Snow: 15:16
  landClass <- cut(landClass, c(0, 5, 11, 14, 16))
  ## Add a Raster Attribute Table and define the raster as categorical data
  landClass <- ratify(landClass)
  ## Configure the RAT: first create a RAT data.frame using the
  ## levels method; second, set the values for each class (to be
  ## used by levelplot); third, assign this RAT to the raster
  ## using again levels
  rat <- levels(landClass)[[1]]
  rat$classes <- c('Forest', 'Land', 'Urban', 'Snow')
  levels(landClass) <- rat
#+end_src

This categorical raster can be displayed with the =levelplot= method
of the =rasterVis= package. Previously, a theme is defined with the
background color set to =lightskyblue1= to display the sea areas
(filled with =NA= values), and the region palette is defined with
adequate colors (Figure \ref{fig:landClass}).

#+BEGIN_LaTeX
\index{Packages!rasterVis@\texttt{rasterVis}}
\index{levelplot@\texttt{levelplot}}
\index{modifyList@\texttt{modifyList}}
\index{rasterTheme@\texttt{rasterTheme}}
#+END_LaTeX

#+begin_src R :results output graphics :exports both :file figs/landClass.pdf
  library(rasterVis)
  
  pal <- c('palegreen4', # Forest
           'lightgoldenrod', # Land
           'indianred4', # Urban
           'snow3')      # Snow
  
  catTheme <- modifyList(rasterTheme(),
                         list(panel.background = list(col='lightskyblue1'),
                              regions = list(col= pal)))
  
  levelplot(landClass, maxpixels=3.5e5, par.settings=catTheme,
            panel=panel.levelplot.raster)
#+end_src

#+CAPTION: Land cover raster (categorical data).
#+LABEL: fig:landClass
#+RESULTS:
[[file:figs/landClass.pdf]]

Let's explore the relation between the land cover and population
density rasters. Figure \ref{fig:populationNASA} displays this
latter raster using a logarithmic scale.

#+begin_src R :results output graphics :exports both :file figs/populationNASA.pdf
  pPop <- levelplot(pop, zscaleLog=10, par.settings=BTCTheme,
                    maxpixels=3.5e5, panel=panel.levelplot.raster)
  pPop
#+end_src

#+CAPTION: Population density raster.
#+LABEL: fig:populationNASA
#+RESULTS:
[[file:figs/populationNASA.pdf]]

Both rasters can be joined together with the =stack= method to
create a new =RasterStack= object. Figure
\ref{fig:histogramLandClass} displays the distribution of the
logarithm of the population density associated to each land class.

#+BEGIN_LaTeX
\index{stack@\texttt{stack}}
\index{histogram@\texttt{histogram}}
#+END_LaTeX

#+begin_src R :results output graphics :exports both :file figs/histogramLandClass.pdf
  s <- stack(pop, landClass)
  names(s) <- c('pop', 'landClass')
  histogram(~log10(pop)|landClass, data=s,
            scales=list(relation='free'))
#+end_src

#+CAPTION: Distribution of the logarithm of the population density associated to each land class.
#+LABEL: fig:histogramLandClass
#+RESULTS:
[[file:figs/histogramLandClass.pdf]]


** \floweroneleft  Multivariate Legend
#+begin_src R :exports none
##################################################################
## Multivariate legend
##################################################################
#+end_src
We can reproduce the code used to create the multivariate
choropleth (Section \ref{sec:multiChoropleth}) using the
=levelplot= function from the =rasterVis= package. Again, the
result is a list of =trellis= objects. Each of these objects is
the representation of the population density in a particular land
class. The =+.trellis= function of the =latticeExtra= package with
=Reduce= superposes the elements of this list and produces a
=trellis= object. Figure \ref{fig:popLandClass} displays the
result.

# #+begin_src R 
#   library(colorspace)
  
#   col2hcl <- function(col){
#     rgb <- t(col2rgb(col))/256
#     luv <- convertColor(rgb, 'sRGB', 'Luv')
#     coords <- as(LUV(luv), 'polarLUV')@coords
#     coords
#     }

#  cols <- colorRampPalette(c('white', pal[i]),  space='Lab')(100)
#  hclPal <- col2hcl(pal[i])
#  cols <- rev(sequential_hcl(100, h=hclPal[1], c=c(hclPal[2], 0), l=c(hclPal[3], 90)))
# #+end_src

#+begin_src R 
  library(colorspace)
  ## at for each sub-levelplot is obtained from the global levelplot
  at <- pPop$legend$bottom$args$key$at
  classes <- rat$classes
  nClasses <- length(classes)
  
  pList <- lapply(1:nClasses, function(i){
    landSub <- landClass
    ## Those cells from a different land class are set to NA...
    landSub[!(landClass==i)] <- NA
    ## ... and the resulting raster masks the population raster
    popSub <- mask(pop, landSub)
    ## The HCL color wheel is divided in nClasses
    step <- 360/nClasses
    ## and a sequential palette is constructed with a hue from one of
    ## the color wheel parts
    cols <- rev(sequential_hcl(16, h = (30 + step*(i-1))%%360))
  
    pClass <- levelplot(popSub, zscaleLog=10, at=at,
                        maxpixels=3.5e5,
                        ## labels only needed in the last legend
                        colorkey=(if (i==nClasses) TRUE else list(labels=list(labels=rep('', 17)))),
                        col.regions=cols, margin=FALSE)
  })
#+end_src


#+begin_src R :results output graphics :exports results :width 2000 :height 2000 :res 300 :file figs/popLandClass.png
  p <- Reduce('+', pList)
  ## Function to add a title to a legend
  addTitle <- function(legend, title){
    titleGrob <- textGrob(title, gp=gpar(fontsize=8), hjust=0.5, vjust=1)
    ## retrieve the legend from the trellis object
    legendGrob <- eval(as.call(c(as.symbol(legend$fun), legend$args)))
    ## Layout of the legend WITH the title
    ly <- grid.layout(ncol=1, nrow=2,
                      widths=unit(0.9, 'grobwidth', data=legendGrob))
    ## Create a frame to host the original legend and the title
    fg <- frameGrob(ly, name=paste('legendTitle', title, sep='_'))
    ## Add the grobs to the frame
    pg <- packGrob(fg, titleGrob, row=2)
    pg <- packGrob(pg, legendGrob, row=1)
    }
  
  ## Access each trellis object from pList...
  for (i in seq_len(nClasses)){
    ## extract the legend (automatically created by spplot)...
    lg <- pList[[i]]$legend$right
    ## ... and add the addTitle function to the legend component of each trellis object
    pList[[i]]$legend$right <- list(fun='addTitle',
                                    args=list(legend=lg, title=classes[i]))
  }
  
  ## List of legends
  legendList <- lapply(pList, function(x){
    lg <- x$legend$right
    clKey <- eval(as.call(c(as.symbol(lg$fun), lg$args)))
    clKey
  })
  
  ## Function to pack the list of legends in a unique legend
  ## Adapted from latticeExtra::: mergedTrellisLegendGrob
  packLegend <- function(legendList){
    N <- length(legendList)
    ly <- grid.layout(nrow = 1,  ncol = N)
    g <- frameGrob(layout = ly, name = "mergedLegend")
    for (i in 1:N) g <- packGrob(g, legendList[[i]], col = i)
    g
  }
  
  ## The legend of p will include all the legends
  p$legend$right <- list(fun = 'packLegend',  args = list(legendList = legendList))
  
  
  p
#+end_src

#+CAPTION: Population density for each land class (multivariate raster).
#+LABEL: fig:popLandClass
#+RESULTS:
[[file:figs/popLandClass.png]]
